<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Difficult Cats</title>
     <script
      type="module"
      src="https://unpkg.com/playhtml@latest/dist/init.es.js">
    </script>

</head>
<style>
#playing-field {
    width: 1500px;
    height: 1000px;
    background: url("/switch/bg.jpg");
    background-repeat: no-repeat;
    background-size: cover;
}


/* Style for toggled elements */
 .disabled {
   opacity: 0.5;
   pointer-events: none; /* Prevents further clicks */
 }
</style>

<script>

</script>

<body>

     <div class="play-contain" >



    <div id="playing-field">
        <img class="mover" src="/switch/1.gif" can-move can-toggle id="play-1"/>
        <img class="mover" src="/switch/2.gif" can-move can-toggle id="play-2"/>
        <img class="mover" src="/switch/3.gif" can-move can-toggle id="play-3"/>
        <img class="mover" src="/switch/4.gif" can-move can-toggle id="play-4"/>
        <img class="mover" src="/switch/5.gif" can-move can-toggle id="play-5"/>
        <img class="mover" src="/switch/6.gif" can-move can-toggle id="play-6"/>
        <img class="mover" src="/switch/7.gif" can-move can-toggle id="play-7"/>
        <img class="mover" src="/switch/8.gif" can-move can-toggle id="play-8"/>
        <img class="mover" src="/switch/9.gif" can-move can-toggle id="play-9"/>
        <img class="mover" src="/switch/10.gif" can-move can-toggle id="play-10"/>
        <img class="mover" src="/switch/11.gif" can-move can-toggle id="play-11"/>
        <img class="mover" src="/switch/12.gif" can-move can-toggle id="play-12"/>
        <img class="mover" src="/switch/13.gif" can-move can-toggle id="play-13"/>


    </div>



<script>
// Configuration
const config = {
  returnDelay: 3000,      // Time in ms before element returns (3 seconds)
  moveDuration: 800,      // Animation duration in ms
  easing: 'ease-out',     // CSS easing function

  // Define elements and their favorite positions (using transform translate)
  elements: [
    {id: "play-1", x: 0, y: 0 },
    {id: "play-2", x: 0, y: 0 },
    {id: "play-3", x: 0, y: 0 },
    {id: "play-4", x: 0, y: 0 },
    {id: "play-5", x: 0, y: 0 },
    {id: "play-6", x: 0, y: 0 },
    {id: "play-7", x: 0, y: 0 },
    {id: "play-8", x: 0, y: 0 },
    {id: "play-9", x: 0, y: 0 },
    {id: "play-10", x: 0, y: 0 },
    {id: "play-11", x: 0, y: 0 },
    {id: "play-12", x: 0, y: 0 },
    {id: "play-13", x: 0, y: 0 }
  ]
};

// Element state tracker
const elementStates = new Map();

// Initialize draggable elements
function initDraggableElements() {
  config.elements.forEach(el => {
    const elem = document.getElementById(el.id);
    if (!elem) return;

    // Don't change positioning - use transform instead
    elem.style.cursor = 'grab';
    elem.style.transition = 'none';

    // Get current transform or set to favorite position
    const currentTransform = window.getComputedStyle(elem).transform;
    if (!currentTransform || currentTransform === 'none') {
      elem.style.transform = `translate(${el.x}px, ${el.y}px)`;
    }

    // Store state
    elementStates.set(el.id, {
      favoriteX: el.x,
      favoriteY: el.y,
      currentX: el.x,
      currentY: el.y,
      returnTimeout: null,
      isDragging: false
    });

    // Add drag listeners for both mouse and touch
    elem.addEventListener('mousedown', onDragStart);
    elem.addEventListener('touchstart', onDragStart, { passive: false });
  });
}

// Unified drag start handler for both mouse and touch
function onDragStart(e) {
  const elem = e.currentTarget;
  const state = elementStates.get(elem.id);

  // Clear any pending return
  if (state.returnTimeout) {
    clearTimeout(state.returnTimeout);
    state.returnTimeout = null;
  }

  state.isDragging = true;
  elem.style.cursor = 'grabbing';
  elem.style.transition = 'none';

  // Get the correct event coordinates (mouse or touch)
  const startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
  const startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

  // Parse current transform to get actual current position
  const transform = window.getComputedStyle(elem).transform;
  let currentX = 0;
  let currentY = 0;

  if (transform && transform !== 'none') {
    const matrix = transform.match(/matrix.*\((.+)\)/);
    if (matrix) {
      const values = matrix[1].split(', ');
      currentX = parseFloat(values[4]) || 0;
      currentY = parseFloat(values[5]) || 0;
    }
  }

  // Store the actual current position at drag start
  const startTranslateX = currentX;
  const startTranslateY = currentY;

  function onDragMove(e) {
    if (!state.isDragging) return;

    // Prevent scrolling on touch devices
    if (e.type === 'touchmove') {
      e.preventDefault();
    }

    const moveX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
    const moveY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

    // Calculate delta from start position
    const deltaX = moveX - startX;
    const deltaY = moveY - startY;

    // Apply transform based on start position + delta
    const newX = startTranslateX + deltaX;
    const newY = startTranslateY + deltaY;

    state.currentX = newX;
    state.currentY = newY;

    elem.style.transform = `translate(${newX}px, ${newY}px)`;
  }

  function onDragEnd() {
    if (!state.isDragging) return;

    state.isDragging = false;
    elem.style.cursor = 'grab';

    // Schedule return to favorite position
    state.returnTimeout = setTimeout(() => {
      returnToFavorite(elem);
    }, config.returnDelay);

    // Remove both mouse and touch listeners
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('touchmove', onDragMove);
    document.removeEventListener('mouseup', onDragEnd);
    document.removeEventListener('touchend', onDragEnd);
    document.removeEventListener('touchcancel', onDragEnd);
  }

  // Add both mouse and touch move/end listeners
  document.addEventListener('mousemove', onDragMove);
  document.addEventListener('touchmove', onDragMove, { passive: false });
  document.addEventListener('mouseup', onDragEnd);
  document.addEventListener('touchend', onDragEnd);
  document.addEventListener('touchcancel', onDragEnd);

  e.preventDefault();
}

// Return element to its favorite position
function returnToFavorite(elem) {
  const state = elementStates.get(elem.id);

  // Enable smooth transition
  elem.style.transition = `transform ${config.moveDuration}ms ${config.easing}`;

  // Move to favorite position
  elem.style.transform = `translate(${state.favoriteX}px, ${state.favoriteY}px)`;
  state.currentX = state.favoriteX;
  state.currentY = state.favoriteY;

  // Remove transition after animation completes
  setTimeout(() => {
    if (!state.isDragging) {
      elem.style.transition = 'none';
    }
  }, config.moveDuration);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initDraggableElements);
} else {
  initDraggableElements();
}

// Export for manual initialization if needed
window.DraggableAutoReturn = {
  init: initDraggableElements,
  config: config
};

</script>
</body>

</html>
