<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Play HTML Example</title>
     <script
      type="module"
      src="https://unpkg.com/playhtml@latest/dist/init.es.js">
    </script>

</head>
<style>
#playing-field {
    width: 1500px;
    height: 1000px;
    background: url("/switch/bg.jpg");
    background-repeat: no-repeat;
    background-size: cover;
}


/* Style for toggled elements */
 .disabled {
   opacity: 0.5;
   pointer-events: none; /* Prevents further clicks */
 }
</style>

<script>
 // // Get all toggleable elements
 // const toggleElements = document.querySelectorAll('[can-toggle]');

 // // Track if any element has been clicked
 // let hasBeenClicked = false;

 // // Add click listeners to each element
 // toggleElements.forEach(element => {
 //   element.addEventListener('click', function(e) {
 //     if (!hasBeenClicked) {
 //       hasBeenClicked = true;

 //       // Disable all OTHER elements
 //       toggleElements.forEach(el => {
 //         if (el !== element) {
 //           el.classList.add('disabled');
 //         }
 //       });
 //     }
 //   });
 // });
</script>

<body>

     <div class="play-contain" >



    <div id="playing-field">
        <img class="mover" src="/switch/1.gif" can-move can-toggle id="play-1"/>
        <img class="mover" src="/switch/2.gif" can-move can-toggle id="play-2"/>
        <img class="mover" src="/switch/3.gif" can-move can-toggle id="play-3"/>
        <img class="mover" src="/switch/4.gif" can-move can-toggle id="play-4"/>
        <img class="mover" src="/switch/5.gif" can-move can-toggle id="play-5"/>
        <img class="mover" src="/switch/6.gif" can-move can-toggle id="play-6"/>
        <img class="mover" src="/switch/7.gif" can-move can-toggle id="play-7"/>
        <img class="mover" src="/switch/8.gif" can-move can-toggle id="play-8"/>
        <img class="mover" src="/switch/9.gif" can-move can-toggle id="play-9"/>
        <img class="mover" src="/switch/10.gif" can-move can-toggle id="play-10"/>
        <img class="mover" src="/switch/11.gif" can-move can-toggle id="play-11"/>
        <img class="mover" src="/switch/12.gif" can-move can-toggle id="play-12"/>
        <img class="mover" src="/switch/13.gif" can-move can-toggle id="play-13"/>


    </div>



<script>


// Configuration
const config = {
  returnDelay: 3000,      // Time in ms before element returns (3 seconds)
  moveDuration: 800,      // Animation duration in ms
  easing: 'ease-out',     // CSS easing function

  // Define elements and their favorite positions
  elements: [
    {id: "play-1", x: 100, y: 100 },
    {id: "play-2", x: 400, y: 150 },
    {id: "play-3", x: 700, y: 200 },
    {id: "play-4", x: 1000, y: 250 },
    {id: "play-5", x: 1200, y: 300 },
    {id: "play-6", x: 200, y: 500 },
    {id: "play-7", x: 500, y: 550 },
    {id: "play-8", x: 800, y: 600 },
    {id: "play-9", x: 1000, y: 650 },
    {id: "play-10", x: 1200, y: 700 },
    {id: "play-11", x: 1000, y: 250 },
    {id: "play-12", x: 1100, y: 300 },
    {id: "play-13", x: 100, y: 700 }
  ]
};

// Element state tracker
const elementStates = new Map();

// Initialize draggable elements
function initDraggableElements() {
  config.elements.forEach(el => {
    const elem = document.getElementById(el.id);
    if (!elem) return;

    // Only set position if not already set
    if (!elem.style.position || elem.style.position === 'static') {
      elem.style.position = 'absolute';
    }
    if (!elem.style.left) {
      elem.style.left = `${el.x}px`;
    }
    if (!elem.style.top) {
      elem.style.top = `${el.y}px`;
    }

    elem.style.cursor = 'grab';
    elem.style.transition = 'none';

    // Store state
    elementStates.set(el.id, {
      favoriteX: el.x,
      favoriteY: el.y,
      returnTimeout: null,
      isDragging: false
    });

    // Add drag listeners for both mouse and touch
    elem.addEventListener('mousedown', onDragStart);
    elem.addEventListener('touchstart', onDragStart, { passive: false });
  });
}

// Unified drag start handler for both mouse and touch
function onDragStart(e) {
  const elem = e.currentTarget;
  const state = elementStates.get(elem.id);

  // Clear any pending return
  if (state.returnTimeout) {
    clearTimeout(state.returnTimeout);
    state.returnTimeout = null;
  }

  state.isDragging = true;
  elem.style.cursor = 'grabbing';
  elem.style.transition = 'none';

  // Get the correct event coordinates (mouse or touch)
  const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
  const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

  // Calculate offset from element's actual position on screen
  const rect = elem.getBoundingClientRect();
  const offsetX = clientX - rect.left;
  const offsetY = clientY - rect.top;

  function onDragMove(e) {
    if (!state.isDragging) return;

    // Prevent scrolling on touch devices
    if (e.type === 'touchmove') {
      e.preventDefault();
    }

    const moveX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
    const moveY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

    const x = moveX - offsetX;
    const y = moveY - offsetY;

    elem.style.left = `${x}px`;
    elem.style.top = `${y}px`;
  }

  function onDragEnd() {
    if (!state.isDragging) return;

    state.isDragging = false;
    elem.style.cursor = 'grab';

    // Schedule return to favorite position
    state.returnTimeout = setTimeout(() => {
      returnToFavorite(elem);
    }, config.returnDelay);

    // Remove both mouse and touch listeners
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('touchmove', onDragMove);
    document.removeEventListener('mouseup', onDragEnd);
    document.removeEventListener('touchend', onDragEnd);
    document.removeEventListener('touchcancel', onDragEnd);
  }

  // Add both mouse and touch move/end listeners
  document.addEventListener('mousemove', onDragMove);
  document.addEventListener('touchmove', onDragMove, { passive: false });
  document.addEventListener('mouseup', onDragEnd);
  document.addEventListener('touchend', onDragEnd);
  document.addEventListener('touchcancel', onDragEnd);

  e.preventDefault();
}

// Return element to its favorite position
function returnToFavorite(elem) {
  const state = elementStates.get(elem.id);

  // Enable smooth transition
  elem.style.transition = `left ${config.moveDuration}ms ${config.easing}, top ${config.moveDuration}ms ${config.easing}`;

  // Move to favorite position
  elem.style.left = `${state.favoriteX}px`;
  elem.style.top = `${state.favoriteY}px`;

  // Remove transition after animation completes
  setTimeout(() => {
    if (!state.isDragging) {
      elem.style.transition = 'none';
    }
  }, config.moveDuration);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initDraggableElements);
} else {
  initDraggableElements();
}

// Export for manual initialization if needed
window.DraggableAutoReturn = {
  init: initDraggableElements,
  config: config
};
</script>
</body>

</html>
